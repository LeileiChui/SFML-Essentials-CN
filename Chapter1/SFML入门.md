# SFML 入门

在本章中，我们将探讨 SFML 的窗口和图形模块，并重点加强我们的基础知识。我们还将看到一个典型的游戏循环在 SFML 中是怎样的，以及我们如何处理输入来操作屏幕上的形状。

在本章中，我们将介绍：

1. 窗口创建

2. 游戏循环

3. 事件处理

4. 形状渲染与变换

#### 创建窗口

当你开始开发游戏时，可能你想做的第一件事就是打开一个窗口。在SFML中，这是非常容易的。创建窗口只需要一行代码：

```cpp
#include <SFML/Window.hpp>
int main(){
    sf::Window window(sf::VideoMode(300,200), "This title");
    return 0;
}
```

> 下载示例代码:
> 你可以下载所有在 http://www.packtpub.com 的你的账户已购买的Packt图书的示例代码文件如果你在别处购买了这本书，你可以访问http://www.packtpub 。COM/SUPPORT和REGISTER将会把文件直接通过电子邮件发送给您。

主函数唯一做的就是通过调用  `sf::Window` 构造函数初始化变量 `window` ，然后程序退出。还有一种打开窗口的替代方法 ，使用默认构造函数并稍后调用 `Window::creat()` 。这个函数接受的参数与我们刚才讨论过的构造函数完全相同。如果对已打开的窗口调用了 `Window::creat` ，则该窗口将关闭，并用新的参数重新初始化。
在前面给出的示例中，请注意 `Window` 和 `VideoMode` 都位于 `sf ` 命名空间中。SFML 中的每个类都位于该命名空间下，它将 SFML 中的所有类与其他库中的类分离开来。

如果我们运行示例中的代码，我们将看不到什么东西。程序在创建窗口后立即退出。这是因为我们只创建了一个窗口而不使用它，并且程序在到达 main() 方法的末尾之后自然退出。我们创建了一个窗口并不意味着它完全可以工作（至少现在还没有）。我们必须根据我们想要它做的事情来对它进行编程。现在，让我们通过延迟窗口的线程来阻止主函数完成。SFML 为此提供了一个简单的接口：只需在创建窗口的行之后添加 `sf::sleep(sf::seconds(3));` 这么一行。现在，在睡眠期间，窗口清晰可见。

我们可以在创建窗口大小、标题、样式和图形设置时指定各种配置。您可能已经注意到，我们向窗口构造函数传递了两个参数：一个 VideoMode 实例和一个字符串（标题）。构造函数实际上可以接受四个参数，最后两个参数是可选的样式和上下文设置。下一部分将介绍这些参数的含义以及如何使用它们。

#### 视频模式

`VideoMode` 类包含有关窗口视频模式的信息，例如宽度、高度和每个像素的位数。最后一个参数是用于表示单个像素颜色的位数。它的默认值为32，这在当前的硬件上不太可能改变。例如，值为8将产生黑白结果。如果我们想要创建一个全屏窗口，提供的值必须被机器的显示器和显卡支持。如果我们为全屏窗口选择了无效的参数，那么窗口创建将失败。可以使用 `VideoMode::isValid()` 方法检查 VideoMode 类的有效性，该方法将返回一个布尔值作为结果。

如果我们需要根据桌面模式的大小（或像素深度）创建一个窗口，那么 `VideoMode:：getDesktopMode()` 可以作为静态方法使用。另一方面，如果我们要在全屏模式下创建一个窗口，我们可能想要用 `VideoMode::getFullScreenModes()` 检查可用分辨率。这返回视频模式的 `std::vector`，我们可以自己选择其中一种模式，或者让用户决定哪种模式最适合他们。

但是，仅仅如上所述的全屏视频模式还不足以创建全屏窗口。我们也需要设定一种风格。

#### 样式

样式参数是一个掩码 (mask)。掩码是标志 (flag) 的组合，其中每个标志表示掩码的特定位。在这种情况下，标志存储在 `sf::Style` 命名空间中的枚举中。我们可以使用标志的组合来创建所需的掩码。以下是SFML提供的样式：

| 类型名称                  | 描述                               |
|:---------------------:|:--------------------------------:|
| sf::Style::None       | 这个窗口没有任何装饰，不能和任何其他样式结合在一起        |
| sf::Style::Titlebar   | 增加一个标题栏                          |
| sf::Style::Resize     | 添加一个最大化按钮，允许手动调整窗口大小             |
| sf::Style::Close      | 添加一个关闭按钮                         |
| sf::Style::Fullscreen | 以全屏模式启动窗口。不能与任何其他样式组合，需要有效的视频模式。 |
| sf::Style::Default    | 包含标题栏、调整大小和关闭，默认样式。              |

组合不同样式的方法是使用按位或运算符。所以在我们想要一个有标题栏和关闭按钮的窗口的情况下，使用下面代码：

```cpp
sf::Uint32 style = sf::Style::Titlebar | sf::Style::Close;
```



这里唯一要做的就是将该样式作为窗口构造的第三个参数传递。

#### 环境设置

最后一个参数是一个 ContextSettings 实例。这个结构体是一组设置，描述所需的渲染环境。SFML 使用 OpenGL 在 hood 下进行渲染，因此这些设置与之直接相关。可用的环境设置如下：

- depthBits: 深度缓冲位的数目。

- stencilBits: 模板缓冲位的数目。

- antialiasingLevel: 要求的多重采样级别数

- majorVersion and minorVersion: 要求的 OpenGL 版本


这些设置都将在第5章“操作二维相机”中得到更详细的解释，您将学习如何使用 OpenGL 直接渲染东西。

#### 禁用鼠标

Windows类有一个方法可以设置光标的显隐： `Window::setMouseCursorVisible()`。这对于不使用光标的游戏很有用，或者当我们想将光标的图像更改为与默认值不同的图像时。

#### 游戏循环

每个游戏都需要一个循环。这就是它保持运行的原因。否则程序就结束了，我们将看不到什么。下面是典型的游戏循环：

```cpp
#include <SFML/Window.hpp>

int main(){
 sf::Window window(sf::VideoMode(800,640),"The title");
 //Game loop
 while(window.isOpen()){
     //输入处理
     //更新画面
     //渲染画面
  }
 return 0;
}
```

典型的游戏循环有三个主要阶段：

- 输入处理
- 更新画面
- 渲染画面



SFML 中的输入处理可以通过捕获窗口发送的事件来完成，也可以通过直接查询输入设备的当前状态来完成。这两种方法都有不同的用途。例如，我们可能希望按下一个按钮的事件发生时关闭窗口，或者只要按下某个键 (直接查询按钮) 就将主人公向右移动。

在捕获和使用事件之后，我们将到达更新画面阶段。在这个阶段，我们希望推进我们的游戏逻辑，更新我们的世界状态。

循环的最后一个阶段就在我们完成对象更新之后。在这里，我们清除上次绘制的所有内容，并再次渲染屏幕上的每个对象。

回到游戏循环的例子中，它当前没有执行它应该执行的操作，如果我们尝试运行代码，很明显窗口对输入没有响应。这是因为我们不执行处理输入的循环中三个重要步骤中的第一个。

#### 事件处理

事件可以通过 `bool Window::pollEvent(sf::Event& event)`从窗口进行轮询。如果有事件等待处理，函数将返回true，事件变量将被事件数据填充。如果不是，则函数返回false。同样重要的是要注意，一次可能有多个事件；因此我们必须确保捕获所有可能的事件。下面是典型的事件循环：

```cpp
while(window.isOpen()){
    sf::Event event;
    while(window.pollEvent(event)){
        //Do something
    }
    //更新画面
    //渲染画面
}
```

现在运行代码可以产生更令人满意的效果：我们可以移动窗口，调整大小，并将其最小化。但是，还有一个问题，关闭按钮不起作用。SFML 不认为在用户单击关闭按钮后窗口应该关闭。也许我们想保存玩家的进度，或者先问他们是否确定。这意味着我们必须自己实现关闭按钮功能。

在继续之前，重要的是注意C++中的 Event 类包含一个联合。这意味着只有一个成员是有效的。访问任何其他成员将导致未定义的行为。我们可以通过查看事件的类型来获取有效的成员。

事件类型可以逻辑地分为四个部分，具体取决于它们与什么相关：

- Window 
- Keyboard 
- Mouse
- Joystick窗口相关事件

#### 窗口相关事件

| 类型名称                                   | 关联的成员                | 描述                                                  |
|:--------------------------------------:|:--------------------:|:---------------------------------------------------:|
| Event::Closed                          | 无                    | 当操作系统检测到用户想要关闭一个窗口、关闭按钮、组合键等时，就会触发此事件。              |
| Event::Resized                         | Event::size：保持窗口的新大小 | 当操作系统检测到窗口已手动调整大小，或当使用了 Window::setSize() 时，会触发此事件。 |
| Event::LostFocus<br>Event::GainedFocus | 无                    | 当窗口失去焦点或获得焦点时触发此事件。不对焦的窗口不接收键盘事件。                   |

#### 键盘相关事件

| 类型名称                                    | 关联的成员                              | 描述                                        |
|:---------------------------------------:|:----------------------------------:|:-----------------------------------------:|
| Event::KeyPressed<br>Event::KeyReleased | Event::key：获取按下/释放的键               | 当在聚焦窗口上按下或释放一个按钮时，会触发此事件。                 |
| Event::TextEntered                      | Event::text：获取输入字符的UTF-32 Unicode值 | 每次键入字符时都会触发此事件。这将从用户输入中生成可打印字符，并对文本字段很有用。 |

#### 鼠标相关事件

| 类型名称                                                     | 关联的成员                              | 描述                                       |
|:--------------------------------------------------------:|:----------------------------------:|:----------------------------------------:|
| Event::MouseMoved                                        | Event::mouseMove：获取鼠标新位置           | 当鼠标更改其在窗口中的位置时，会触发此事件。                   |
| Event::MouseButtonPressed<br/>Event::MouseButtonReleased | Event::mouseButton：获取按下/释放的按钮和鼠标位置 | 当在窗口中按下鼠标按钮时触发此事件。目前支持左、右、中、额外按钮1和额外按钮2。 |
| Event::MouseWheelMoved                                   | Event::mouseWheel：获取 滚轮刻度和鼠标位置     | 当滚轮在窗口内移动时触发此事件。                         |

#### 游戏手柄相关事件

| 类型名称                                                           | 关联的成员                                  | 描述                                                                   |
|:--------------------------------------------------------------:|:--------------------------------------:|:--------------------------------------------------------------------:|
| Event::JoystickConnected<br/>Event::JoystickDisconnected       | Event::joystickConnect：获取刚刚链接/断开的手柄的ID | 手柄连接或断开时触发此事件。                                                       |
| Event::JoystickButtonPressed<br/>Event::JoystickButtonReleased | Event::joystickButton：获取按下按钮的编号和手柄ID   | 按下操纵杆上的按钮时触发。SFML 最多支持8个操纵杆，每个操纵杆最多32个按钮。                            |
| Event::JoystickMoved                                           | Event::joystickMove：获取移动轴、新轴位置和手柄ID    | 当操纵杆的轴移动时触发。可以通过`Window::setJoystick Threshold()`设置移动阈值。SFML最多支持8个轴。 |
